<!doctype html>
<html lang="pt-BR">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flashcards – Redes de Computadores</title>
  <style>
    :root {
      --bg: #0f172a;
      /* slate-900 */
      --panel: #111827ee;
      /* gray-900 */
      --muted: #94a3b8;
      /* slate-400 */
      --text: #e5e7eb;
      /* gray-200 */
      --accent: #22d3ee;
      /* cyan-400 */
      --accent-2: #a78bfa;
      /* violet-400 */
      --good: #34d399;
      /* emerald-400 */
    }

    * {
      box-sizing: border-box
    }

    body {
      margin: 0;
      background: #0f172a;
      font-family: Inter, system-ui, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text)
    }

    header {
      padding: 24px 18px;
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between
    }

    header h1 {
      font-size: 20px;
      margin: 0;
      letter-spacing: .2px
    }

    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center
    }

    select,
    button,
    input[type="search"] {
      background: #0b1220;
      border: 1px solid #1f2937;
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      outline: none
    }

    button {
      cursor: pointer;
      transition: .2s transform, .3s background
    }

    button:hover {
      transform: translateY(-1px)
    }

    .pill {
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid #1f2937;
      background: #0a0f1a;
      color: var(--muted)
    }

    .stats {
      display: flex;
      gap: 8px;
      align-items: center
    }

    main {
      max-width: 1100px;
      margin: 0 auto;
      padding: 0 16px 48px
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px
    }

    .card {
      position: relative;
      min-height: 220px;
      background: linear-gradient(180deg, #0b1324, #0e1426);
      border: 1px solid #203048;
      border-radius: 18px;
      perspective: 1000px;
      box-shadow: 0 10px 30px #0004
    }

    .inner {
      position: relative;
      width: 100%;
      height: 100%;
      transition: transform .5s;
      transform-style: preserve-3d
    }

    .card.flipped .inner {
      transform: rotateY(180deg)
    }

    .face {
      position: absolute;
      inset: 0;
      padding: 18px 16px 50px 16px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      backface-visibility: hidden;
      border-radius: 18px
    }

    .back {
      transform: rotateY(180deg)
    }

    .topic {
      font-size: 12px;
      color: var(--accent);
      letter-spacing: .4px;
      text-transform: uppercase
    }

    .q {
      font-size: 15px;
      line-height: 1.35
    }

    .a {
      font-size: 14px;
      color: #d1d5db
    }

    .toolbar {
      position: absolute;
      left: 10px;
      right: 10px;
      bottom: 10px;
      display: flex;
      gap: 8px;
      justify-content: space-between
    }

    .toolbar .left {
      display: flex;
      gap: 8px
    }

    .tag {
      font-size: 11px;
      color: #c7d2fe;
      border: 1px dashed #374151;
      border-radius: 10px;
      padding: 4px 8px;
      opacity: .8
    }

    .ok {
      border-color: #14532d;
      color: #86efac
    }

    .btn {
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid #243041;
      background: #0a1222
    }

    .primary {
      border-color: #155e75;
      background: #083344
    }

    .muted {
      color: var(--muted)
    }

    .footer {
      margin-top: 10px;
      font-size: 12px;
      color: #9ca3af
    }

    .hidden {
      display: none
    }

    .stack-mode {
      margin: 18px 0 8px
    }

    .stack {
      max-width: 740px;
      margin: 0 auto
    }

    .big {
      min-height: 280px
    }
  </style>
</head>

<body>
  <header>
    <h1>Flashcards – Redes de Computadores</h1>
    <div class="controls">
      <input id="search" type="search" placeholder="buscar… (ex.: DNS, HTTP, camada de rede)" />
      <select id="topic"></select>
      <select id="sub"></select>
      <button id="import" class="btn">Importar CSV</button>
      <input id="file" type="file" accept=".csv,text/csv" class="hidden" />
      <button id="shuffle" class="btn">Embaralhar</button>
      <span class="pill stats" id="stats">0/0</span>
      <button id="reset" class="btn">Zerar Progresso</button>
    </div>
  </header>
  <main>
    <section id="grid" class="grid"></section>
  </main>
  <script>
    // ===== Storage / CSV Import =================================================
    const STORAGE_CARDS_KEY = 'rc_cards';

    function loadCards() {
      try {
        const raw = JSON.parse(localStorage.getItem(STORAGE_CARDS_KEY) || '[]');
        return Array.isArray(raw) ? raw : [];
      } catch (e) {
        console.warn('Cartas inválidas no localStorage. Reiniciando.');
        return [];
      }
    }

    function saveCards(cards) {
      localStorage.setItem(STORAGE_CARDS_KEY, JSON.stringify(cards));
    }

    function sniffDelimiter(text) {
      const first = (text.split(/\r?\n/)[0] || '');
      const commas = (first.match(/,/g) || []).length;
      const semis = (first.match(/;/g) || []).length;
      return semis > commas ? ';' : ',';
    }

    function parseCSV(text) {
      const delim = sniffDelimiter(text);
      const rows = [];
      let row = [];
      let cell = '';
      let inQuotes = false;
      for (let i = 0; i < text.length; i++) {
        const ch = text[i];
        if (ch === '"') {
          if (inQuotes && text[i + 1] === '"') { cell += '"'; i++; }
          else { inQuotes = !inQuotes; }
        } else if (ch === '\r') {
          // ignore
        } else if (ch === '\n') {
          if (inQuotes) { cell += '\n'; }
          else { row.push(cell); rows.push(row); row = []; cell = ''; }
        } else if (ch === delim && !inQuotes) {
          row.push(cell); cell = '';
        } else {
          cell += ch;
        }
      }
      if (cell.length > 0 || row.length > 0) { row.push(cell); rows.push(row); }
      rows.forEach(r => { for (let i = 0; i < r.length; i++) r[i] = (r[i] || '').trim(); });
      return rows.filter(r => r.length && r.join('').length);
    }

    function normalizeKey(s) {
      return (s || '')
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z]/g, '');
    }

    function csvToCards(text) {
      const rows = parseCSV(text);
      if (!rows.length) return [];
      const header = rows[0].map(normalizeKey);
      const idx = { topic: -1, sub: -1, q: -1, a: -1 };
      header.forEach((h, i) => {
        if (h === 'topic' || h === 'topico' || h === 'assunto') idx.topic = i;
        else if (h === 'sub' || h === 'subtopic' || h === 'subtopico') idx.sub = i;
        else if (h === 'q' || h === 'question' || h === 'pergunta' || h === 'questao') idx.q = i;
        else if (h === 'a' || h === 'answer' || h === 'resposta') idx.a = i;
      });
      if (idx.q === -1 && header.length >= 2) { idx.q = 0; idx.a = 1; }
      const cards = [];
      for (let r = 1; r < rows.length; r++) {
        const row = rows[r];
        const q = idx.q >= 0 ? (row[idx.q] || '').trim() : '';
        const a = idx.a >= 0 ? (row[idx.a] || '').trim() : '';
        if (!q || !a) continue;
        const topic = idx.topic >= 0 ? (row[idx.topic] || '').trim() : 'Importado';
        const sub = idx.sub >= 0 ? (row[idx.sub] || '').trim() : 'Geral';
        cards.push({ topic, sub, q, a });
      }
      cards.forEach((c, i) => c.id = i + 1);
      return cards;
    }

    // ===== App State ============================================================
    function safeProgress() {
      try { return new Set(JSON.parse(localStorage.getItem('rc_progress') || '[]')); }
      catch (e) { console.warn('Progresso inválido no localStorage. Reiniciando.'); return new Set(); }
    }
    const state = {
      all: [],
      filtered: [],
      progress: safeProgress(),
    };

    function init() {
      // carregar cartas importadas (se existirem)
      state.all = loadCards();
      selfTestsState();
      renderFilters();
      applyFilters();
      bindGlobal();
    }

    // ----- Filtros -----
    function renderFilters() {
      const topics = [...new Set(state.all.map(c => c.topic))];
      const topicSel = document.getElementById('topic');
      topicSel.innerHTML = ['<option value="">Todos os tópicos</option>']
        .concat(topics.map(t => `<option>${t}</option>`)).join('');

      const subSel = document.getElementById('sub');
      subSel.innerHTML = '<option value="">Todos os subtópicos</option>';

      topicSel.addEventListener('change', () => {
        const subs = [...new Set(state.all.filter(c => !topicSel.value || c.topic === topicSel.value).map(c => c.sub))];
        document.getElementById('sub').innerHTML = ['<option value="">Todos os subtópicos</option>']
          .concat(subs.map(s => `<option>${s}</option>`)).join('');
        applyFilters();
      });
      document.getElementById('sub').addEventListener('change', applyFilters);
      document.getElementById('search').addEventListener('input', debounce(applyFilters, 140));
    }

    function applyFilters() {
      const q = document.getElementById('search').value.toLowerCase();
      const t = document.getElementById('topic').value;
      const s = document.getElementById('sub').value;
      state.filtered = state.all.filter(c =>
        (!t || c.topic === t) && (!s || c.sub === s) && (!q || (c.q + " " + c.a + " " + c.topic + " " + c.sub).toLowerCase().includes(q))
      );
      renderGrid();
      updateStats();
    }

    // ----- Grid de cartas -----
    function renderGrid() {
      const grid = document.getElementById('grid');
      if (state.all.length === 0) {
        grid.innerHTML = '<div class="pill muted big">Nenhum cartão. Clique em "Importar CSV" e use cabeçalho: topic,sub,q,a</div>';
        return;
      }
      if (state.filtered.length === 0) {
        grid.innerHTML = '<div class="pill muted">Nenhum resultado para os filtros atuais.</div>';
        return;
      }
      grid.innerHTML = state.filtered.map(renderCard).join('');
      grid.querySelectorAll('.card').forEach(card => attachCardEvents(card));
    }

    function renderCard(c) {
      const learned = state.progress.has(c.id);
      return `<article class="card ${learned ? 'learned' : ''}" data-id="${c.id}">
    <div class="inner">
      <div class="face front">
        <span class="topic">${c.topic}</span>
        <div class="q">${c.q}</div>
        <div class="toolbar">
          <div class="left">
            <span class="tag">${c.sub}</span>
            <span class="tag">#${c.id}</span>
          </div>
          <div>
            <button class="btn primary flip">Mostrar resposta</button>
          </div>
        </div>
      </div>
      <div class="face back">
        <span class="topic">Resposta</span>
        <div class="a">${c.a}</div>
        <div class="toolbar">
          <div class="left">
            <button class="btn mark">${learned ? 'Desmarcar memorizado' : 'Marcar como memorizado'}</button>
          </div>
          <div>
            <button class="btn flip">Voltar</button>
          </div>
        </div>
      </div>
    </div>
  </article>`
    }

    function attachCardEvents(card) {
      const id = +card.dataset.id;
      card.addEventListener('click', e => {
        if (e.target.closest('button')) return; // evita flip ao clicar no botão
        card.classList.toggle('flipped');
      });
      card.querySelectorAll('.flip').forEach(btn => btn.addEventListener('click', () => card.classList.toggle('flipped')));
      card.querySelector('.mark').addEventListener('click', () => {
        if (state.progress.has(id)) {
          state.progress.delete(id);
        } else {
          state.progress.add(id);
        }
        persistProgress();
        updateStats();
        renderGrid(); // Atualiza o botão e o visual
      });
    }

    function persistProgress() {
      localStorage.setItem('rc_progress', JSON.stringify([...state.progress]));
    }

    function updateStats() {
      // Conta quantos cartões do filtro atual estão memorizados
      const learned = state.filtered.filter(c => state.progress.has(c.id)).length;
      const total = state.filtered.length;
      document.getElementById('stats').textContent = `${learned}/${total}`;
    }

    // ----- Modo pilha (estudo focado) -----
    function bindGlobal() {
      document.getElementById('shuffle').onclick = () => { shuffle(state.filtered); renderGrid(); };
      document.getElementById('reset').onclick = () => { if (confirm('Limpar progresso salvo?')) { state.progress.clear(); persistProgress(); updateStats(); renderGrid(); } };
      document.getElementById('import').onclick = () => { document.getElementById('file').click(); };
      document.getElementById('file').onchange = async (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        try {
          const text = await file.text();
          const cards = csvToCards(text);
          if (!cards.length) { alert('CSV vazio ou sem cartões válidos.'); return; }
          state.progress.clear();
          persistProgress();
          saveCards(cards);
          state.all = cards;
          // reset filtros
          document.getElementById('topic').value = '';
          document.getElementById('sub').value = '';
          document.getElementById('search').value = '';
          renderFilters();
          applyFilters();
          alert('Cartões importados: ' + cards.length);
        } catch (err) {
          console.error(err);
          alert('Falha ao importar CSV.');
        } finally {
          e.target.value = '';
        }
      };
    }

    // ----- Utils -----
    function shuffle(arr) { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[arr[i], arr[j]] = [arr[j], arr[i]] } }
    function debounce(fn, ms) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms) } }

    // ===== Self-tests (dev) =====
    function selfTestsState() {
      console.groupCollapsed('Flashcards – self-tests (STATE)');
      const ids = new Set();
      let dup = false; state.all.forEach(c => { if (ids.has(c.id)) dup = true; ids.add(c.id); });
      console.assert(!dup, 'IDs dos cards devem ser únicos');
      console.groupEnd();
    }

    init();
  </script>
</body>

</html>